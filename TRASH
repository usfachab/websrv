// if ( uri.find_first_of( '?' ) != std::string::npos )
// {
// 	query	=	uri.substr( queryPos + 1 );
// 	uri.resize( uri.length() - ( query.length() + 1 ) );
// 	if ( !query.empty() )
// 	{
// 		std::stringstream ss( query );
// 		size_t numberOfQueries = std::count( query.begin(), query.end(), '&' ) + 1;

// 		for ( int i = 0; i <  numberOfQueries; i++)
// 		{
// 			std::getline( ss, param, '&' );
// 			if ( !param.empty() )
// 			{
// 				size_t	equalPos = param.find_first_of( '=' );
// 				if ( equalPos != std::string::npos )
// 				{
// 					std::string key		( param.substr( 0, equalPos ) );
// 					std::string value	( param.substr( key.length() + 1 , param.length() - ( key.length() + 1 ) ) );

// 					queries.insert( std::pair<std::string, std::string>( key, value ) );
// 				}
// 				else
// 					queries.insert( std::pair<std::string, std::string>( param, "" ) );
// 			}
// 		}
// 	}
// }



// void	HTTPRequest::handleBodYrest()
// {
// 	int			index = 0;
// 	std::string line;
// 	std::string chunkData;

// 	size_t	chunkSize;
// 	size_t	start;

// 	COUT( "Parse chunked body rest" );
// 	while ( index < 2 )
// 	{
// 		crs.eofChunkPos  = eofChunk( crs.eofChunkPos, crs.bodYrest );
// 		COUT( crs.eofChunkPos );
// 		if ( index == 0 )
// 		{
// 			std::string chunklen = crs.bodYrest.substr( 0,  crs.eofChunkPos );
// 			chunkSize = std::strtol( chunklen.c_str(), NULL, 16 );
// 			if ( chunkSize == LONG_MAX || chunkSize == LONG_MIN )
// 				throw std::invalid_argument( "bad request: chunk size corrupted" );
// 			crs.eofChunkPos += 2;
// 			start = crs.eofChunkPos;
// 		}
// 		else
// 		{
// 			if ( crs.eofChunkPos != std::string::npos )
// 			{
// 				std::string toWrite( crs.bodYrest.substr( start, chunkSize  ) );
// 				COUT( toWrite );
// 			}
// 		}
// 		index++;
// 	}
// }

// size_t HTTPRequest::eofChunk( size_t startPos, std::string& chunk )
// {
// 	bool cr = false;
// 	bool fl = false;

// 	size_t crPos = 0;
// 	size_t flPos = 0;

// 	for ( int i = startPos; i < chunk.length(); i++ )
// 	{
// 		if ( chunk.at( i ) == '\r' )
// 		{
// 			cr = !cr;
// 			crPos = i;
// 		}
// 		else if ( chunk.at( i ) == '\n' )
// 		{
// 			fl = !fl;
// 			flPos = i;
// 		}
// 		if ( cr == true && fl == true && flPos == crPos + 1 )
// 			return ( crPos );
// 	}
// 		return ( std::string::npos );
// }


// void	HTTPRequest::handleBodYrest()
// {
// 	long		chunkSize;
// 	std::string	hexliteral;
// 	std::string	toWrite;
// 	std::string	chunkContent;
// 	size_t		crlfPos;

// 	COUT( "handle BodY rest" );

// 	hexliteral	=	crs.bodYrest.substr( 0, crs.bodYrest.find( '\r' ) );
// 	chunkSize	=	std::strtol( hexliteral.c_str(), NULL, 16 );

// 	crs.bodYrest = crs.bodYrest.substr( hexliteral.length() + 2 );

// 	crlfPos = eofChunk( 0, crs.bodYrest );

// 	if ( crlfPos != std::string::npos )
// 		chunkContent = crs.bodYrest.substr( 0, crlfPos );
// 	else
// 		chunkContent = crs.bodYrest.substr( 0 , crs.bodYrest.length() );

// 	if ( chunkSize > chunkContent.length() ) // ba9i mayt9ra
// 		crs.restOfBodYrest = chunkSize - chunkContent.length();
	
// 	if ( chunkSize < chunkContent.length() ) // imkn to9a3 ila kano chunks sghar

// 	if ( chunkSize == chunkContent.length() ) // mab9a mayt9ra
		
// 	crs.bodYrest.clear();
// }
