// if ( uri.find_first_of( '?' ) != std::string::npos )
// {
// 	query	=	uri.substr( queryPos + 1 );
// 	uri.resize( uri.length() - ( query.length() + 1 ) );
// 	if ( !query.empty() )
// 	{
// 		std::stringstream ss( query );
// 		size_t numberOfQueries = std::count( query.begin(), query.end(), '&' ) + 1;

// 		for ( int i = 0; i <  numberOfQueries; i++)
// 		{
// 			std::getline( ss, param, '&' );
// 			if ( !param.empty() )
// 			{
// 				size_t	equalPos = param.find_first_of( '=' );
// 				if ( equalPos != std::string::npos )
// 				{
// 					std::string key		( param.substr( 0, equalPos ) );
// 					std::string value	( param.substr( key.length() + 1 , param.length() - ( key.length() + 1 ) ) );

// 					queries.insert( std::pair<std::string, std::string>( key, value ) );
// 				}
// 				else
// 					queries.insert( std::pair<std::string, std::string>( param, "" ) );
// 			}
// 		}
// 	}
// }



// void	HTTPRequest::handleBodYrest()
// {
// 	int			index = 0;
// 	std::string line;
// 	std::string chunkData;

// 	size_t	chunkSize;
// 	size_t	start;

// 	COUT( "Parse chunked body rest" );
// 	while ( index < 2 )
// 	{
// 		crs.eofChunkPos  = eofChunk( crs.eofChunkPos, crs.bodYrest );
// 		COUT( crs.eofChunkPos );
// 		if ( index == 0 )
// 		{
// 			std::string chunklen = crs.bodYrest.substr( 0,  crs.eofChunkPos );
// 			chunkSize = std::strtol( chunklen.c_str(), NULL, 16 );
// 			if ( chunkSize == LONG_MAX || chunkSize == LONG_MIN )
// 				throw std::invalid_argument( "bad request: chunk size corrupted" );
// 			crs.eofChunkPos += 2;
// 			start = crs.eofChunkPos;
// 		}
// 		else
// 		{
// 			if ( crs.eofChunkPos != std::string::npos )
// 			{
// 				std::string toWrite( crs.bodYrest.substr( start, chunkSize  ) );
// 				COUT( toWrite );
// 			}
// 		}
// 		index++;
// 	}
// }

// size_t eofChunk( size_t startPos, std::string& chunk )
// {
// 	bool cr = false;
// 	bool fl = false;

// 	size_t crPos = 0;
// 	size_t flPos = 0;

// 	for ( int i = startPos; i < chunk.length(); i++ )
// 	{
// 		if ( chunk.at( i ) == '\r' )
// 		{
// 			cr = !cr;
// 			crPos = i;
// 		}
// 		else if ( chunk.at( i ) == '\n' )
// 		{
// 			fl = !fl;
// 			flPos = i;
// 		}
// 		if ( cr == true && fl == true && flPos == crPos + 1 )
// 			return ( crPos );
// 	}
// 		return ( std::string::npos );
// }


// void	HTTPRequest::handleBodYrest()
// {
// 	long		chunkSize;
// 	std::string	hexliteral;
// 	std::string	toWrite;
// 	std::string	chunkContent;
// 	size_t		crlfPos;

// 	COUT( "handle BodY rest" );

// 	hexliteral	=	crs.bodYrest.substr( 0, crs.bodYrest.find( '\r' ) );
// 	chunkSize	=	std::strtol( hexliteral.c_str(), NULL, 16 );

// 	crs.bodYrest = crs.bodYrest.substr( hexliteral.length() + 2 );

// 	crlfPos = eofChunk( 0, crs.bodYrest );

// 	if ( crlfPos != std::string::npos )
// 		chunkContent = crs.bodYrest.substr( 0, crlfPos );
// 	else
// 		chunkContent = crs.bodYrest.substr( 0 , crs.bodYrest.length() );

// 	if ( chunkSize > chunkContent.length() ) // ba9i mayt9ra
// 		crs.restOfBodYrest = chunkSize - chunkContent.length();
	
// 	if ( chunkSize < chunkContent.length() ) // imkn to9a3 ila kano chunks sghar

// 	if ( chunkSize == chunkContent.length() ) // mab9a mayt9ra
		
// 	crs.bodYrest.clear();
// }



// #include "./include/include.hpp"

// void	handleChunks( int fd, std::string buffer, bool& Continue, long& chunkSize )
// {
// 	static int	count = 0;
// 	std::string	hex;

// 	for ( int i = 0; i < buffer.length(); ++i )
// 	{
// 		if ( Continue == false )
// 		{
// 			count = 0;
// 			while ( i < buffer.length() && buffer[ i ] != '\r' )
// 			{
// 				hex.push_back( buffer[ i ] );
// 				i++;
// 			}
// 			if ( !hex.empty() )
// 			{
// 				chunkSize = std::strtol( hex.c_str(), NULL, 16 );
// 				hex.clear();
// 				i += 2;
// 				if ( chunkSize == 0 )
// 					exit( 0 );
// 			}
// 		}
// 		while ( i < buffer.length() )
// 		{
// 			if ( buffer[ i ] == '\r' )
// 			{
// 				Continue = false;
// 				i += 1;
// 				chunkSize = 0;
// 				count = 0;
// 				break ;
// 			}
// 			write( 1, &buffer[ i ], 1 );
// 			count++;
// 			i++;
// 		}
// 		if ( count < chunkSize )
// 			Continue = true;
// 	}
// }

// int main()
// {
// 	int fd = open( "./file", O_RDONLY );
// 	int output = open( "./output", O_CREAT | O_RDWR, 0666 );
// 	long chunkSize = 0;
// 	char buffer[ 256 ];
// 	bool Continue = false;

// 	while ( true )
// 	{
// 		int rd = read( fd, buffer, 255 );
// 		if ( rd > 0 )
// 		{
// 			buffer[ rd ] = 0;
// 			handleChunks( output,  buffer, Continue, chunkSize);
// 		}
// 		if ( rd <= 0 )
// 			break;
// 	}
// 	return 0;
// }